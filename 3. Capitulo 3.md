# Capítulo 3: Criando o Workflow Completo de CI/CD

Neste capítulo vamos criar um workflow completo de CI/CD para a nossa aplicação FastAPI hospedada na Azure.

O workflow terá as seguintes etapas:

- Checkout do código
- Setup do ambiente Python
- Instalação das dependências
- Lint do código
- Análise de qualidade e segurança
- Testes unitários
- Deploy automático via SSH
- Análise de segurança pós-deploy com OWASP ZAP

---

## Arquivo completo `.github/workflows/ci-cd.yml`

```yaml
name: CI/CD - Build, Testes e Deploy

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**/*.md'

jobs:
  build-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Instalar dependências
        run: |
          pip install -r requirements.txt \
                      ruff pylint mypy bandit pip-audit black pytest

      - name: Lint com Ruff
        run: ruff app

      - name: Análise de código com Pylint
        run: pylint app

      - name: Verificação de tipagem com mypy
        run: mypy app

      - name: Análise de segurança com Bandit
        run: bandit -r app

      - name: Auditoria de dependências com pip-audit
        run: pip-audit

      - name: Verificação de formatação com Black
        run: black --check app

      - name: Executar testes unitários
        run: pytest -q

  deploy:
    needs: build-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Deploy via SSH na VM
        uses: appleboy/ssh-action@v0.1.6
        with:
          host: ${{ secrets.VM_IP }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_KEY }}
          script: |
            cd ~/CI-CD-tutorial-completo
            git pull origin main
            docker compose down
            docker compose up -d

      - name: Security Scan com OWASP ZAP
        uses: zaproxy/action-baseline@v0.10.0
        with:
          target: 'http://${{ secrets.VM_IP }}:8000'
          fail_action: false
```

---

# Explicação do workflow `ci-cd.yml`

## Bloco 1: Evento que dispara o workflow

```yaml
on:
  push:
    branches:
      - main
    paths-ignore:
      - '**/*.md'
```

### Explicação

- **on:** Define **em qual evento** o workflow deve ser executado.
- **push:** Ocorre **quando há um push de código** para o repositório.
- **branches: [main]:** Só executa **se o push for na branch `main`**.
- **paths-ignore: ['**/*.md']:** Se o push modificar apenas arquivos `.md`, o workflow **não será acionado**.

### Resumo técnico

| Campo | Função |
|:------|:-------|
| `on` | Define o gatilho do workflow |
| `push` | Evento de envio de código |
| `branches: ["main"]` | Restringe a execução apenas para a branch principal |
| `paths-ignore: ["**/*.md"]` | Ignora alterações em arquivos Markdown |

---

## Bloco 2: Definição dos `jobs`

```yaml
jobs:
  build-test:
    runs-on: ubuntu-latest
```

### Explicação

- **jobs:**  
  Define os **conjuntos de tarefas** que serão executadas.  
  Cada `job` é independente e pode rodar em paralelo (a menos que se declare dependências).
  
- **build-test:**  
  É o **nome do primeiro job** que criamos.  
  Este job será responsável por:
  - Instalar o ambiente
  - Rodar lints
  - Analisar segurança
  - Executar testes

- **runs-on: ubuntu-latest:**  
  Define **em qual ambiente** o job será executado.  
  Aqui escolhemos a imagem mais atual do Ubuntu disponibilizada pelo GitHub.

---

## Resumo técnico

| Campo | Função |
|:------|:-------|
| `jobs` | Agrupamento de tarefas que o workflow vai executar |
| `build-test` | Nome do primeiro conjunto de tarefas |
| `runs-on: ubuntu-latest` | Define o sistema operacional da máquina virtual do GitHub Actions |

---

Se aprovar, seguimos para a próxima explicação:  
**bloco 3: primeiros steps do `build-test` (Checkout do código e Setup Python)**.  
Confirmo para seguir?
